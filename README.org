#+TITLE: Readme
#+AUTHOR: valentin
#+SETUPFILE: ~/Daten/cloud/tlaloc/org/setupfiles/latex.setup

* About this Project
These are my dotfiles (settings for programs I customized so much that I can't
go without them and don't want to hassle setting my environment up again).

The idea is - store settings in your git Account and just clone them and you're
good to go.


** About this Documentation

As you might have noticed, the dotfiles are relatively well documented. Every
folder contains a documentation for the exact program.
It is accomplished using [[https://orgmode.org][Org Mode]] in [[https://www.gitlab.com/hlissner/doom-emacs][Doom]] on [[https://www.gnu.org/software/emacs/Emacs][Emacs]] with my [[./.doom.d/config.org][personal configuration]] (this
renders best viewed in Emacs, I don't know if the link works in gitlab).

* Magit Forge

This contains my api key for connecting to gitlab and working/editing gitlab
issues using [[https://github.com/magit/forge/][magit-forge]]
I do not include this here, because it would be stored unencrypted.

* Git
This is my global git configuration

This is basic configuration
#+BEGIN_SRC git :tangle .config/git/config
[user]
	email = valentin_lechner@dismail.de
	name = valentin_lechner
#+END_SRC
It can be set using
#+BEGIN_SRC sh
git config --global user.name <your user>
git config --global user.email <your email>
#+END_SRC

This configures git to use my private key to sign every commit
#+BEGIN_SRC git :tangle .config/git/config
	signingkey = 9C489382
[commit]
	gpgsign = true
#+END_SRC
Some other stuff I configured, probably not too important
#+BEGIN_SRC git :tangle .config/git/config
[gitlab]
	user = valentin_lechner
[pull]
	rebase = false
#+END_SRC
* Tmux
I use the terminal multiplexer [[https://github.com/tmux/tmux][tmux]], which basically is a window manager for
your terminal and allows you to outsource some unnecessary work that your terminal does to
tmux. It allows to use multiple terminals in the same window in splits.

Since I found the default keybinding =C-b= hard to reach, I settled for =C-a=. When
I connected to a screen-session on a server, I ran into keybinding issues. For
now, I solved it using =C-s= as my keybinding. Seems good so far.
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
unbind C-b
set-option -g prefix C-s
bind-key C-s send-prefix
#+END_SRC

Everyone knows that we count from zero
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
set -g base-index 0
#+END_SRC

Automatically set window title
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
set-window-option -g automatic-rename on
set-option -g set-titles on
#+END_SRC
Some basic stuff
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
set -g default-terminal "screen-256color"
set -g history-limit 10000
#+END_SRC
Evil mode everywhere
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
set -g status-keys vi
setw -g mode-keys vi
#+END_SRC
This notifies you when something changes in another window
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
setw -g monitor-activity on
#+END_SRC
Add some sensible keybindings for splitting windows.
=C-s + v=: split vertically
=C-s + h=: split horizontally
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
bind-key v split-window -h
bind-key s split-window -v
#+END_SRC
Evil resizing using Uppercase hjkl
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
bind-key J resize-pane -D 5
bind-key K resize-pane -U 5
bind-key H resize-pane -L 5
bind-key L resize-pane -R 5
bind-key M-j resize-pane -D
bind-key M-k resize-pane -U
bind-key M-h resize-pane -L
bind-key M-l resize-pane -R
#+END_SRC
Evil style pane selection
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

#+END_SRC
Use Alt-vim keys without prefix key to switch panes
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
bind -n M-h select-pane -L
bind -n M-j select-pane -D
bind -n M-k select-pane -U
bind -n M-l select-pane -R
#+END_SRC


No delay for escape key press
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
set -sg escape-time 0
#+END_SRC
Reload tmux config
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
bind r source-file ~/.config/tmux/tmux.conf
#+END_SRC


THEME
#+BEGIN_SRC sh :tangle .config/tmux/tmux.conf
set -g status-bg default
set -g status-fg green
set -g status-interval 60
set -g status-left-length 30
set -g status-left '#[fg=green](#S) #(whoami)'
set -g status-right '#[fg=yellow]#(cut -d " " -f 1-3 /proc/loadavg)#[default] #[fg=white]%H:%M#[default]'
#+END_SRC

* Zsh

** .zshenv

Relocate some config files to be located in =~/.config= instead of =~=
#+BEGIN_SRC sh :tangle .zshenv
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DATA_HOME="$XDG_CONFIG_HOME/local/share"
export XDG_CACHE_HOME="$XDG_CONFIG_HOME/cache"
#+END_SRC
Relocate zsh config dir. Only this file =.zshenv= has to be in =~=
#+BEGIN_SRC sh :tangle .zshenv
export ZDOTDIR="${XDG_CONFIG_HOME:-$HOME/.config}/zsh"
#+END_SRC

Relocate zsh history file
#+BEGIN_SRC sh :tangle .zshenv
export HISTFILE="$ZDOTDIR/.zhistory"
export HISTSIZE=100000
export SAVEHIST=$HISTSIZE
#+END_SRC

Set default editor to emacs
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
export EDITOR='emacs -nw'
export VISUAL='emacs -nw'
#+END_SRC

*** Additional Relocations

GTK2
#+BEGIN_SRC sh :tangle .zshenv
export GTK2_RC_FILES="${XDG_CONFIG_HOME:-$HOME/.config}/gtk-2.0/gtkrc-2.0"
#+END_SRC
WGET
#+BEGIN_SRC sh :tangle .zshenv
export WGETRC="${XDG_CONFIG_HOME:-$HOME/.config}/wget/wgetrc"
#+END_SRC
TMUX
#+BEGIN_SRC sh :tangle .zshenv
export TMUX_TMPDIR="$XDG_RUNTIME_DIR"
#+END_SRC
Android SDK
#+BEGIN_SRC sh :tangle .zshenv
export ANDROID_SDK_HOME="${XDG_CONFIG_HOME:-$HOME/.config}/android"
#+END_SRC
Rust
#+BEGIN_SRC sh :tangle .zshenv
export CARGO_HOME="${XDG_DATA_HOME:-$HOME/.config/local/share}/cargo"
#+END_SRC
Go
#+BEGIN_SRC sh :tangle .zshenv
export GOPATH="${XDG_DATA_HOME:-$HOME/.config/local/share}/go"
#+END_SRC
Ansible
#+BEGIN_SRC sh :tangle .zshenv
export ANSIBLE_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/ansible/ansible.cfg"
#+END_SRC

*** lf icons

#+BEGIN_SRC sh :tangle .zshenv
# This is the list for lf icons:
export LF_ICONS="di=ðŸ“:\
fi=ðŸ“ƒ:\
tw=ðŸ¤:\
ow=ðŸ“‚:\
ln=â›“:\
or=âŒ:\
ex=ðŸŽ¯:\
*.txt=âœ:\
*.mom=âœ:\
*.me=âœ:\
*.ms=âœ:\
*.png=ðŸ–¼:\
*.webp=ðŸ–¼:\
*.ico=ðŸ–¼:\
*.jpg=ðŸ“¸:\
*.jpe=ðŸ“¸:\
*.jpeg=ðŸ“¸:\
*.gif=ðŸ–¼:\
*.svg=ðŸ—º:\
*.tif=ðŸ–¼:\
*.tiff=ðŸ–¼:\
*.xcf=ðŸ–Œ:\
*.html=ðŸŒŽ:\
*.xml=ðŸ“°:\
*.gpg=ðŸ”’:\
*.css=ðŸŽ¨:\
*.pdf=ðŸ“š:\
*.djvu=ðŸ“š:\
*.epub=ðŸ“š:\
*.csv=ðŸ““:\
*.xlsx=ðŸ““:\
*.tex=ðŸ“œ:\
*.md=ðŸ“˜:\
*.r=ðŸ“Š:\
*.R=ðŸ“Š:\
*.rmd=ðŸ“Š:\
*.Rmd=ðŸ“Š:\
*.m=ðŸ“Š:\
*.mp3=ðŸŽµ:\
*.opus=ðŸŽµ:\
*.ogg=ðŸŽµ:\
*.m4a=ðŸŽµ:\
*.flac=ðŸŽ¼:\
*.mkv=ðŸŽ¥:\
*.mp4=ðŸŽ¥:\
*.webm=ðŸŽ¥:\
*.mpeg=ðŸŽ¥:\
*.avi=ðŸŽ¥:\
*.zip=ðŸ“¦:\
*.rar=ðŸ“¦:\
*.7z=ðŸ“¦:\
*.tar.gz=ðŸ“¦:\
*.z64=ðŸŽ®:\
*.v64=ðŸŽ®:\
*.n64=ðŸŽ®:\
*.gba=ðŸŽ®:\
*.nes=ðŸŽ®:\
*.gdi=ðŸŽ®:\
*.1=â„¹:\
*.nfo=â„¹:\
*.info=â„¹:\
*.log=ðŸ“™:\
*.iso=ðŸ“€:\
*.img=ðŸ“€:\
*.bib=ðŸŽ“:\
*.ged=ðŸ‘ª:\
*.part=ðŸ’”:\
*.torrent=ðŸ”½:\
*.jar=â™¨:\
*.java=â™¨:\
"
#+END_SRC

** .zshrc

*** Autocompletion/Typos
I use [[github:nvbn/thefuck][thefuck]] for correcting typos
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
eval $(thefuck --alias)
#+END_SRC
requires =thefuck=
#+BEGIN_SRC sh
pip install thefuck
#+END_SRC
Enable autocompletions
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
autoload -Uz compinit
#+END_SRC
Use cache for autocompletion
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
typeset -i updated_at=$(date +'%j' -r ~/.zcompdump 2>/dev/null || stat -f '%Sm' -t '%j' ~/.zcompdump 2>/dev/null)

if [ $(date +'%j') != $updated_at ]; then
  compinit -i
else
  compinit -C -i
fi
#+END_SRC
Menuselect
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zmodload -i zsh/complist
#+END_SRC
Improve autocompletion style
sel completion with arrow
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zstyle ':completion:*' menu select
#+END_SRC
group results by cat
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zstyle ':completion:*' group-name ''
#+END_SRC
enable approximate matches
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zstyle ':completion:::::' completer _expand _complete _ignored _approximate
#+END_SRC
Highlight the current autocomplete option
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
#+END_SRC

Better SSH/Rsync/SCP Autocomplete
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zstyle ':completion:*:(scp|rsync):*' tag-order ' hosts:-ipaddr:ip\ address hosts:-host:host files'
zstyle ':completion:*:(ssh|scp|rsync):*:hosts-host' ignored-patterns '*(.|:)*' loopback ip6-loopback localhost ip6-localhost broadcasthost
zstyle ':completion:*:(ssh|scp|rsync):*:hosts-ipaddr' ignored-patterns '^(<->.<->.<->.<->|(|::)([[:xdigit:].]##:(#c,2))##(|%*))' '127.0.0.<->' '255.255.255.255' '::1' 'fe80::*'
#+END_SRC
Allow for autocomplete to be case insensitive
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zstyle ':completion:*' matcher-list '' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' \
  '+l:|?=** r:|?=**'
#+END_SRC
*** Evil
Evil everywhere
- use vim keybindings in term
- use h,j,k,l to navigate in complete menus
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
bindkey -v
# makes the switch between modes quicker
export KEYTIMEOUT=1
# Use vim keys in tab complete menu:
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char
#+END_SRC

#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
zle -N zle-keymap-select
zle-line-init() {
    # initiate `vi insert` as keymap (can be removed if `bindkey -V` has been set elsewhere)
    # zle -K viins
    echo -ne "\e[5 q"
}
#+END_SRC

Change cursor shape for different vi modes.
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
function zle-keymap-select {
  if [[ ${KEYMAP} == vicmd ]] ||
     [[ $1 = 'block' ]]; then
    echo -ne '\e[1 q'
  elif [[ ${KEYMAP} == main ]] ||
       [[ ${KEYMAP} == viins ]] ||
       [[ ${KEYMAP} = '' ]] ||
       [[ $1 = 'beam' ]]; then
    echo -ne '\e[5 q'
  fi
}
zle -N zle-line-init
# beam cursor on startup
echo -ne '\e[5 q'
# beam cursor for new prompt
preexec() { echo -ne '\e[5 q' ;}
#+END_SRC

*** Options
 cd by typing directory name if it's not a command
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt auto_cd
#+END_SRC
automatically list choices on ambiguous completion
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt auto_list
#+END_SRC
menu completion
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt auto_menu
#+END_SRC
move cursor to end if match
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt always_to_end
#+END_SRC
remove old duplicates from hist
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt hist_ignore_all_dups
#+END_SRC
remove superfluous blanks from hist
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt hist_reduce_blanks
#+END_SRC
hist gets saved when entered
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt inc_append_history
#+END_SRC
shares hist between instances
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt share_history
#+END_SRC
allow comments in interactive shells
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt interactive_comments
#+END_SRC
Push the current dir visited to the stack
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt AUTO_PUSHD
#+END_SRC
Do not store duplicates in the stack
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt PUSHD_IGNORE_DUPS
#+END_SRC

Do not print dir after pushd or popd
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt PUSHD_SILENT
#+END_SRC

Allow for customization of Prompt
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
setopt PROMPT_SUBST
#+END_SRC

*** Keybindings

Use lf to switch directories and bind it to ctrl-o
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
lfcd () {
    tmp="$(mktemp)"
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp" >/dev/null
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
    fi
}
bindkey -s '^o' 'lfcd\n'
#+END_SRC
open calculator with ctrl+b
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
bindkey -s '^b' 'bc -l\n'
#+END_SRC
fzf using C-f
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
bindkey -s '^f' 'cd "$(dirname "$(fzf)")"\n'
#+END_SRC
Edit line in vim with C-e:
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
autoload edit-command-line; zle -N edit-command-line
bindkey '^e' edit-command-line
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down
bindkey '^[[3~' delete-char
bindkey '^[3;5~' delete-char
#+END_SRC
*** Aliases

#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
source "$ZDOTDIR/.zsh_aliases"
#+END_SRC

*** Functions

- =what= is my function to look sth up in the web browser
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
what(){vimb "searx.neocities.org?q=$1"}
#+END_SRC

- =git_info= is a function to display the status of the git repository
  in the work directory

#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
# Echoes information about Git repository status when inside a Git repository
git_info() {

  # Exit if not inside a Git repository
  ! git rev-parse --is-inside-work-tree > /dev/null 2>&1 && return

  # Git branch/tag, or name-rev if on detached head
  local GIT_LOCATION=${$(git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD)#(refs/heads/|tags/)}

  local AHEAD="%{$fg[red]%}â‡¡NUM%{$reset_color%}"
  local BEHIND="%{$fg[cyan]%}â‡£NUM%{$reset_color%}"
  local MERGING="%{$fg[magenta]%}âš¡ï¸Ž%{$reset_color%}"
  local UNTRACKED="%{$fg[red]%}â—%{$reset_color%}"
  local MODIFIED="%{$fg[yellow]%}â—%{$reset_color%}"
  local STAGED="%{$fg[green]%}â—%{$reset_color%}"

  local -a DIVERGENCES
  local -a FLAGS

  local NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$NUM_AHEAD" -gt 0 ]; then
    DIVERGENCES+=( "${AHEAD//NUM/$NUM_AHEAD}" )
  fi

  local NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$NUM_BEHIND" -gt 0 ]; then
    DIVERGENCES+=( "${BEHIND//NUM/$NUM_BEHIND}" )
  fi

  local GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
  if [ -n $GIT_DIR ] && test -r $GIT_DIR/MERGE_HEAD; then
    FLAGS+=( "$MERGING" )
  fi

  if [[ -n $(git ls-files --other --exclude-standard 2> /dev/null) ]]; then
    FLAGS+=( "$UNTRACKED" )
  fi

  if ! git diff --quiet 2> /dev/null; then
    FLAGS+=( "$MODIFIED" )
  fi

  if ! git diff --cached --quiet 2> /dev/null; then
    FLAGS+=( "$STAGED" )
  fi

  local -a GIT_INFO
  GIT_INFO+=( "\033[38;5;15mÂ±" )
  [ -n "$GIT_STATUS" ] && GIT_INFO+=( "$GIT_STATUS" )
  [[ ${#DIVERGENCES[@]} -ne 0 ]] && GIT_INFO+=( "${(j::)DIVERGENCES}" )
  [[ ${#FLAGS[@]} -ne 0 ]] && GIT_INFO+=( "${(j::)FLAGS}" )
  GIT_INFO+=( "\033[38;5;15m$GIT_LOCATION%{$reset_color%}" )
  echo "${(j: :)GIT_INFO}"

}
#+END_SRC


*** Tmux

Open tmux and start the ssh agent
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
[ -z "$TMUX" ] && eval $(ssh-agent -s) && ssh-add ~/.ssh.id_ed25519

case $- in *i* )
    [ -z "$TMUX" ] && command -v tmux &> /dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && exec tmux new-session -A -s main ;;
esac
#+END_SRC
*** Antibody

Load antibody plugin manager
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
source <(antibody init)
#+END_SRC
Plugins
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
antibody bundle mafredri/zsh-async
antibody bundle zsh-users/zsh-autosuggestions
antibody bundle zsh-users/zsh-history-substring-search
antibody bundle zsh-users/zsh-completions
#+END_SRC

*** Colors

Load Colors from Xresources.
They can be used using {$color}
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
autoload -U colors && colors
#+END_SRC

*** Prompt

#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
autoload -U promptinit
promptinit
PROMPT="$prompt_newline%F{blue}%2~%f$prompt_newline%(?.%F{green}.%F{red})Î»%f "
RPROMPT='%(?..%F{red}[%?]%f)'
#+END_SRC



*** Last one

This is for syntax highlighting while typing. Loaded last so everything gets highlighted
#+BEGIN_SRC sh :tangle .config/zsh/.zshrc
antibody bundle zdharma/fast-syntax-highlighting
#+END_SRC



** .zsh_aliases

*** Basic aliases

- =doas=: For desktop usage I tend to use doas as privilege escalation tool. It's easier set up
- =exa= is a sexier ls
#+BEGIN_SRC sh :tangle .config/zsh/.zsh_aliases
alias sudo='doas'
alias ls='exa -alh --color=always'
#+END_SRC

*** Directory

- Every dir visited will populate the stack
- using d shows the stack
- then typing the number allows you to go back to the dir
#+BEGIN_SRC sh :tangle .config/zsh/.zsh_aliases
alias d='dirs -v'
for index ({1..9}) alias "$index"="cd +${index}"; unset index
#+END_SRC

*** Powercontrol

#+BEGIN_SRC sh :tangle .config/zsh/.zsh_aliases
alias poweroff='sudo poweroff'
alias reboot='sudo reboot'
#+END_SRC

*** Git Aliases
#+BEGIN_SRC sh :tangle .config/zsh/.zsh_aliases
alias gs='git status'
alias ga='git add'
alias gp='git push'
alias gpo='git push origin'
alias gtd='git tag --delete'
alias gtdr='git tag --delete origin'
alias gr='git branch -r'
alias gplo='git pull origin'
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias gco='git checkout '
alias gl='git log'
alias gr='git remote'
alias grs='git remote show'
alias glo='git log --pretty="oneline"'
alias glol='git log --graph --oneline --decorate'
#+END_SRC

** .zprofile

*** Proxychains

I configured =proxychains= to connect to a running tor service. =proxychains= allows
to set the =conf= file via the variable =PROXYCHAINS_CONF_FILE=. Usually, it is
located in the home directory - this bloats home, so I decided to put it into
.config
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
[ -d "$HOME/.config/proxychains" ] && export PROXYCHAINS_CONF_FILE="$HOME/.config/proxychains/proxychains.conf"
#+END_SRC



*** Path variables

This contains a set of add-to-path-if-exists stuff.
Meaning, cargo stuff will only be in path if the folder is there and so on.


Set Android Development specific vars
# #+BEGIN_SRC sh :tangle .config/zsh/.zprofile
# [ -d "$HOME/Android/Sdk" ]  && export ANDROID_HOME="$HOME/Android/Sdk"
#
# [ -z "$ANDROID_HOME" ]      && [ -d "$ANDROID_HOME/platform-tools" ] && PATH="$ANDROID_HOME/platform-tools"
# [ -z "$ANDROID_HOME" ]      && [ -d "$ANDROID_HOME/tools" ]          && PATH="$ANDROID_HOME/tools"
#+END_SRC
go progs (f.e lf)
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
[ -n "$GOPATH" ] && [ -d "$GOPATH/bin" ]       && PATH="$GOPATH/bin:$PATH"
#+END_SRC
doom Emacs
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
[ -d "$HOME/.emacs.d/bin" ] && PATH="$HOME/.emacs.d/bin:$PATH"
#+END_SRC
More recent emacs versions (>= 27) save their configuration in the
$XDG_CONFIG_DIR
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
[ -d "$XDG_CONFIG_HOME/emacs" ] && PATH="$XDG_CONFIG_HOME/emacs/bin:$PATH"
#+END_SRC
Python
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
[ -d "$XDG_CONFIG_HOME/local/bin" ]   && PATH="$XDG_CONFIG_HOME/local/bin:$PATH"
#+END_SRC
cargo for rusty stuff
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
[ -n "$CARGO_HOME" ] && [ -d "$CARGO_HOME/bin" ]   && PATH="$CARGO_HOME/bin:$PATH"
#+END_SRC
And export path
#+BEGIN_SRC sh :tangle .config/zsh/.zprofile
export PATH
#+END_SRC





* Bash

I don't really use bash anymore, I favor [[https://www.zsh.org][Zsh]], that's why this part is probably
not up-to-date and not as well documented.

** .bashrc

#+BEGIN_SRC bash :tangle .bashrc :shebang "#!/usr/bin/env bash"
shopt -s extglob
# turns off cowbell
xset -b

cd "$HOME" || return
eval "$(thefuck --alias)"

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$HOME/.nvm/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$HOME/.nvm/bash_completion"

export EDITOR='vim'

# schneide float ab -> int
fk_cutfloat()
{
    float=$1
    int=${float%.*}
    echo "$int"
}


# openssl password generator
fk_passwdgen() {
    openssl rand -base64 "$1"
}

# cd .. n times
.. ()
{
        local arg=${1:-1};
        local dir=""
        while [ "$arg" -gt 0 ]; do
            dir="../$dir"
            arg=$(("$arg" - 1));
        done
        cd $dir >&/dev/null || echo "Directory does not exist" && exit 2
}

#start command in bg, redir output to /dev/null
fk_s()
{
    ("$@" & disown ) >/dev/null 2>&1 </dev/null
      which "$1" >/dev/null 2>&1
}

fk_zathura()
{
    fk_s zathura "$1"
}

fk_extract()
{
      if [ -f "$1" ] ; then
              case "$1" in
                  *.tar.bz2)   tar xvjf "$1"    ;;
                  *.tar.gz)    tar xvzf "$1"    ;;
                  *.bz2)       bunzip2 "$1"     ;;
                  *.rar)       rar x "$1"       ;;
                  *.gz)        gunzip "$1"      ;;
                  *.tar)       tar xvf "$1"     ;;
                  *.tbz2)      tar xvjf "$1"    ;;
                  *.tgz)       tar xvzf "$1"    ;;
                  *.zip)       unzip "$1"       ;;
                  *.Z)         uncompress "$1"  ;;
                  *.7z)        7z x "$1"        ;;
                  *)           echo "don't know how to extract $1..." ;;
              esac
      else
              echo "$1"" is not a valid file!"
      fi
}

# wetter
weather()
{
    curl "https://wttr.in/$1"
}

fk_bandit()
{
    cat ~/bandit/bandit"$1"
    ssh bandit"$1"@bandit.labs.overthewire.org -p 2220
}

fk_addbanditkey()
{
    echo "$1" > ~/bandit/bandit"$2"
}

fk_alarm(){
    (speaker-test --frequency "$1" --test sine)& pid=$!;sleep 0.2;kill -9 $pid
}

#************************************************
#             Projektordner Ã¶ffnen
#************************************************

# aktuelles projekt
alias cda='cd ~/.dev && echo $(tput setaf 1) No project specified'

# aktuelles zweitprojekt
alias cdzp='cd ~/.dev && echo $(tput setaf 1) No project specified'

# Projekteordner
alias cdp='cd ~/.dev/'
#+END_SRC
** .bash_profile

#+BEGIN_SRC bash :tangle .bash_profile :shebang "#!/usr/bin/env bash"
[[ -f ~/.bashrc ]] && . ~/.bashrc

export PYTHONIOENCODING=UTF-8

#eval `keychain --eval $(cat $HOME/.ssh/sshkeys)` 
if [ -n "$DESKTOP_SESSION" ];then
    eval "$(gnome-keyring-daemon --start)"
    export SSH_AUTH_SOCK
fi
#+END_SRC

** .bash_aliases

#+BEGIN_SRC bash :tangle .bash_aliases :shebang "#!/usr/bin/env bash"
# v = vim
alias v='vim'
# konfigurationsdateien
alias brc='vim ~/.bashrc'
alias ba='vim ~/.bash_aliases'

# wget autoresume
alias wget='wget -c'


# verbesserte ls's
alias ls='ls -h --color'
alias ll='ls -l'
alias la='ll -A'
#+END_SRC

* X Stuff

The [[https://x.org/wiki][X Window System]] is a system used on many linux desktops. It might soon
become deprecated as [[https://wayland.freedesktop.org/][Wayland]] seems to be a lot easier.
There's already a lot of window managers supporting wayland, I still use X
though.

Since I use [[https://github.com/CanonicalLtd/lightdm][LightDM]] as Login Manager with [[github:prikhi/lightdm-mini-greeter]], I
do not use =.xinitrc= or =.xprofile=.
** .Xresources

=.Xresources= can be used to set Parameters of X Computer Programs.
It can be used to configure terminal preferences and fonts and stuff, also there
is a number of applications whose conf-File is =.Xresources=, namely the terminal
emulator rxvt-unicode. In my case, I installed [[https://github.com/jcaw/theme-magic][theme-magic-from-emacs]], which is
available on [[https://melpa.org/][MELPA]] and [[https://github.com/dylanaraps/pywal][pywal]] to generate it for my favorite emacs theme
=doom-moonlight=.

This is the base colorset
#+BEGIN_SRC text :tangle .Xresources :exports code
*.color0: #202236
*color0:  #202236
*.color1: #FE747E
*color1:  #FE747E
*.color2: #7987CE
*color2:  #7987CE
*.color3: #FEC676
*color3:  #FEC676
*.color4: #BF98FE
*color4:  #BF98FE
*.color5: #C2E78C
*color5:  #C2E78C
*.color6: #81A9FE
*color6:  #81A9FE
*.color7: #C7D2F4
*color7:  #C7D2F4
*.color8: #434972
*color8:  #434972
*.color9: #FE747E
*color9:  #FE747E
*.color10: #7987CE
*color10:  #7987CE
*.color11: #FEC676
*color11:  #FEC676
*.color12: #BF98FE
*color12:  #BF98FE
*.color13: #C2E78C
*color13:  #C2E78C
*.color14: #81A9FE
*color14:  #81A9FE
*.color15: #C7D2F4
*color15:  #C7D2F4
#+END_SRC
This black color will not be affected by bold highlighting.
#+BEGIN_SRC text :tangle .Xresources :exports code
*.color66: #202236
*color66:  #202236
#+END_SRC
* BSPWM
#+INCLUDE: .config/bspwm/README.org :lines "4-"
* SXHKD
#+INCLUDE: .config/sxhkd/README.org :lines "4-"
 


# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
